{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PostgreSQL Notes","text":"<p>Personal notes on PostgreSQL.</p>"},{"location":"json-processing/","title":"JSON processing","text":""},{"location":"json-processing/#json-operators","title":"JSON Operators","text":"Demo data<pre><code>{\n\"firstName\": \"Gonzo\",\n\"lastName\": \"Puppet\",\n\"age\": 81,\n\"streetAddress\": \"100 Internet Dr\",\n\"city\": \"MuppetTown\",\n\"state\": \"MP\",\n\"postalCode\": \"12345\",\n\"phoneNumbers\": [\n{\n\"mobile\": \"111-111-1111\"\n},\n{\n\"home\": \"222-222-2222\"\n}\n]\n}\n</code></pre> Accessing JSON ValuesQuerying containmentQuerying containment (JSONPath) Description Operator Example field in JSON object <code>-&gt; text</code> <code>demo -&gt; 'streetAddress'</code>\"100 Internet Dr\" element in JSON array <code>-&gt; integer</code> <code>demo -&gt; 'phoneNumbers' -&gt; 1</code> '{ \"home\": \"222-222-2222\" }' deep access by path segments <code>#&gt; text[]</code> <code>demo #&gt; '{phoneNumbers, 1, home}'</code> \"222-222-2222\" <p>Retrieving text values instead of JSON values</p> <p>Extending the operator with a second <code>&gt;</code> character, i.e. <code>-&gt;&gt;, #&gt;&gt;</code>, returns the JSON value as text rather than as JSONB.</p> Description Operator Example contains JSON ? <code>@&gt; jsonb</code> <code>demo @&gt; '{\"firstName\": \"Gonzo\"}'::jsonb</code> true is JSON contained ? <code>&lt;@ jsonb</code> <code>'{\"firstName\": \"Gonzo\"}'::jsonb &lt;@ demo</code> true contains top-level key ? <code>? text</code> <code>demo ? 'fullName'</code> false contains any top-level key ? <code>?| text[]</code> <code>demo ?| '{fullName, firstName, lastName}'</code> true contains all top-level keys ? <code>?&amp; text[]</code> <code>demo ?&amp; '{fullName, firstName, lastName}'</code> false Operator Example <code>@? jsonpath</code> <code>demo @? '$.age ? (@ &gt; 80)'</code>true <code>@@ jsonpath</code> <code>demo @@ '$.age &gt; 80'</code>true"},{"location":"json-processing/#json-functions","title":"JSON Functions","text":""},{"location":"top-n-rows-from-each-group/","title":"Top N rows from each group","text":""},{"location":"top-n-rows-from-each-group/#sample-data","title":"Sample data","text":"id name dep salary 1 Mike Management 5000 2 Devon Accounting 1000 3 Jane Accounting 1500 4 Chiara IT 2000 5 Alex IT 3000 6 Tim IT 3000"},{"location":"top-n-rows-from-each-group/#problem","title":"Problem","text":"<p>For each department, find the N employee(s) with the highest salary.</p>"},{"location":"top-n-rows-from-each-group/#solutions","title":"Solutions","text":"DISTINCT ONLateral joinWindow functionCorrelated subquery <pre><code>select distinct on (dep)\n*\nfrom\nemployees\norder by\ndep\n, salary desc\n</code></pre> Output<pre><code> id | name |    dep     | salary  \n----+------+------------+--------\n 3  | Jane | Accounting |  1500   \n 5  | Alex |     IT     |  3000   \n 1  | Mike | Management |  5000   \n</code></pre> <p>Note</p> <p>With <code>DISTINCT ON</code> we are limited to exactly the first row from each group.</p> <p>If there are multiple rows with the same salary in a group, provide additional <code>ORDER BY</code> columns to resolve the ambiguity.</p> <p>Note</p> <p>The <code>DISTINCT ON</code> expression(s) must match the leftmost <code>ORDER BY</code> expression(s).</p> <p><code>ORDER BY</code> will usually contain additional expression(s) that determine the desired precedence of rows within each group.</p> <p><code>DISTINCT ON</code> accepts multiple columns.</p> <pre><code>select distinct on (department, sub_department)\n...\n</code></pre> <p><code>DISTINCT ON</code> is a PostgreSQL extension to the SQL standard.</p> <pre><code>select\ne.*\nfrom\nemployees e\n, lateral (\nselect\n*\nfrom\nemployees\nwhere\ndep = e.dep\norder by salary desc\nlimit 1  -- or limit N\n) sq\nwhere\ne.id = sq.id\norder by\ndep, salary desc\n</code></pre> Output<pre><code> id | name |    dep     | salary  \n----+------+------------+--------\n 3  | Jane | Accounting |  1500   \n 5  | Alex |     IT     |  3000   \n 1  | Mike | Management |  5000   \n</code></pre> <p>Note</p> <p>If there are multiple rows with the same salary in a group, provide additional <code>ORDER BY</code> columns to the lateral subquery to resolve the ambiguity.</p> <p>Note</p> <p>The <code>,</code> in the <code>FROM</code> clause is shorthand for <code>CROSS JOIN</code>.</p> <pre><code>select\n*\nfrom\n(\nselect\n*\n, rank() over (partition by dep order by salary desc) rank\nfrom\nemployees\n) sq\nwhere\nrank = 1  -- or rank &lt;= N\n</code></pre> Output<pre><code> id | name |    dep     | salary | rank  \n----+------+------------+--------+------\n 3  | Jane | Accounting |  1500  |  1    \n 5  | Alex |     IT     |  3000  |  1    \n 6  | Tim  |     IT     |  3000  |  1    \n 1  | Mike | Management |  5000  |  1    \n</code></pre> <pre><code>select\n*\nfrom\nemployees e\nwhere\nid = (\nselect\nid\nfrom\nemployees\nwhere\ndep = e.dep\norder by salary desc\nlimit 1  -- or limit N\n)\n)\n</code></pre> Output<pre><code> id | name |    dep     | salary  \n----+------+------------+--------\n 1  | Mike | Management |  5000   \n 3  | Jane | Accounting |  1500   \n 5  | Alex |     IT     |  3000   \n</code></pre> <p>Note</p> <p>If there are multiple rows with the same salary in a group, provide additional <code>ORDER BY</code> columns to the subquery to resolve the ambiguity.</p>"},{"location":"top-n-rows-from-each-group/#references","title":"References","text":"<ul> <li>SO: Select first row in each GROUP BY group?</li> <li>PostgreSQL: DISTINCT ON</li> <li>PostgreSQL: LATERAL</li> <li>PostgreSQL: Window functions</li> <li>PostgreSQL: Scalar subqueries</li> </ul>"}]}